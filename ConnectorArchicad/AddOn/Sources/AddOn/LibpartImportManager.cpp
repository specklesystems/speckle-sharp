#include "LibpartImportManager.hpp"

#include "BuiltInLibrary.hpp"
#include "FileSystem.hpp"
#include "Folder.hpp"
#include "GSUnID.hpp"
#include "MD5Channel.hpp"
#include "AttributeManager.hpp"

LibpartImportManager::LibpartImportManager ()
{
	AttributeManager attributeManager;
	attributeManager.GetDefaultMaterial (defaultMaterialAttribute, defaultMaterialName);
}


GSErrCode LibpartImportManager::GetLibpart (const ModelInfo& modelInfo, AttributeManager& attributeManager, API_LibPart& libPart)
{
	GS::UInt64 checksum = GenerateFingerPrint (modelInfo.GetIds ());
	GSErrCode err = Error;
	if (cache.Get (checksum, &libPart)) {
		err = NoError;
	} else {
		err = CreateLibraryPart (modelInfo, attributeManager, libPart);
		if (err == NoError)
			cache.Add (checksum, libPart);
	}

	return err;
}


GSErrCode LibpartImportManager::CreateLibraryPart (const ModelInfo& modelInfo, AttributeManager& attributeManager, API_LibPart& libPart)
{
	GSErrCode err = NoError;
	BNZeroMemory (&libPart, sizeof (API_LibPart));
	libPart.typeID = APILib_ObjectID;
	libPart.isTemplate = false;
	libPart.isPlaceable = true;

	// todo use Speckle types here
	const GS::UnID unID = BL::BuiltInLibraryMainGuidContainer::GetInstance ().GetUnIDWithNullRevGuid (BL::BuiltInLibPartID::BuildingElementLibPartID);
	CHCopyC (unID.ToUniString ().ToCStr (), libPart.parentUnID);

	GS::ucscpy (libPart.docu_UName, L ("Speckle Object"));

	err = GetLocation (libPart.location, true);
	if (err != NoError)
		return err;

	err = ACAPI_LibPart_Create (&libPart);
	if (err == NoError) {
		char buffer[1000];

		API_LibPartSection section;

		// Comment script section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_SectComText;
		ACAPI_LibPart_NewSection (&section);
		sprintf (buffer, "Speckle");
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		ACAPI_LibPart_EndSection ();

		// Keyword section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_SectKeywords;
		ACAPI_LibPart_NewSection (&section);
		sprintf (buffer, "Speckle");
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		ACAPI_LibPart_EndSection ();

		// Copyright section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_SectCopyright;
		ACAPI_LibPart_NewSection (&section);
		sprintf (buffer, "Speckle Systems");	// Author
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		ACAPI_LibPart_EndSection ();

		// Master script section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_Sect1DScript;
		ACAPI_LibPart_NewSection (&section);
		buffer[0] = '\0';
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		ACAPI_LibPart_EndSection ();

		// 3D script section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_Sect3DScript;
		ACAPI_LibPart_NewSection (&section);

		sprintf (buffer, "!%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "! 3D Script (Generated by Speckle Connector)%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "!%s%s", GS::EOL, GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

		sprintf (buffer, "defaultResolution = 36%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "RESOL defaultResolution%s%s", GS::EOL, GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

		sprintf (buffer, "hiddenProfileEdge = 0%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "hiddenBodyEdge = 0%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "smoothBodyEdge = 0%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "visibleBodyEdge = 262144%s%s", GS::EOL, GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

		sprintf (buffer, "IF (GLOB_CONTEXT %% 10 >= 2 AND GLOB_CONTEXT %% 10 <= 4) AND showOnlyContourEdgesIn3D <> 0 THEN%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "\thiddenProfileEdge = 1%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "\thiddenBodyEdge = 1%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "\tsmoothBodyEdge = 2%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "ENDIF%s%s", GS::EOL, GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

		sprintf (buffer, "!%s%s", GS::EOL, GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "RESOL defaultResolution%s%s", GS::EOL, GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "XFORM map_xform[1][1], map_xform[2][1], map_xform[3][1], map_xform[4][1],%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "\tmap_xform[1][2], map_xform[2][2], map_xform[3][2], map_xform[4][2],%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "\tmap_xform[1][3], map_xform[2][3], map_xform[3][3], map_xform[4][3]%s%s", GS::EOL, GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

		// create material
		GS::Array<ModelInfo::Material> materials = modelInfo.GetMaterials ();
		for (const auto& material : materials) {
			API_Attribute materialAttribute;
			attributeManager.GetMaterial (material, materialAttribute);
		}

		GS::Array<ModelInfo::Vertex> vertices = modelInfo.GetVertices ();
		for (UInt32 i = 0; i < vertices.GetSize (); i++) {
			sprintf (buffer, "VERT %f, %f, %f\t!#%d%s", vertices[i].GetX (), vertices[i].GetY (), vertices[i].GetZ (), i + 1, GS::EOL);
			ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		}

		sprintf (buffer, "%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

		GS::HashTable<GS::Pair<Int32, Int32>, GS::UShort> edges = modelInfo.GetEdges ();

		UInt32 edgeIndex = 1;
		UInt32 polygonIndex = 1;
		GS::Array<ModelInfo::Polygon> polygons = modelInfo.GetPolygons ();
		for (const auto& polygon : polygons) {
			const GS::Array<Int32>& pointIds = polygon.GetPointIds ();
			UInt32 pointsCount = pointIds.GetSize ();

			GS::UniString materialName = defaultMaterialName;
			{
				ModelInfo::Material material;
				if (NoError == modelInfo.GetMaterial (polygon.GetMaterial (), material)) {
					materialName = material.GetName ();
				}
			}
			
			sprintf (buffer, "! Polygon #%d%s%sMATERIAL \"%s\"%s", polygonIndex, GS::EOL, GS::EOL, materialName.ToCStr ().Get (), GS::EOL);
			ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
			
			for (UInt32 i = 0; i < pointsCount; i++) {
				Int32 start = i;
				Int32 end = i == pointIds.GetSize () - 1 ? 0 : i + 1;

				Int32 startPointId = pointIds[start], endPointId = pointIds[end];
				GS::Pair<Int32, Int32> edge (startPointId, endPointId);

				bool smooth = false;
				bool hidden = false;
				if (edges.ContainsKey(edge)) {
					switch (edges[edge]) {
					case ModelInfo::HiddenEdge:
						hidden = true;
						break;
					case ModelInfo::SmoothEdge:
						smooth = true;
						break;
					case ModelInfo::VisibleEdge:
						break;
					default:
						break;
					}
				}

				sprintf (buffer, "EDGE %d, %d, -1, -1, %s\t!#%d%s", pointIds[start] + 1, pointIds[end] + 1, (smooth ? "smoothBodyEdge" : (hidden ? "hiddenBodyEdge" : "visibleBodyEdge")), edgeIndex + i, GS::EOL);
				ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
			}

			sprintf (buffer, "PGON %d, 0, -1", pointsCount);
			ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

			for (UInt32 i = 0; i < pointsCount; i++) {
				sprintf (buffer, ", %d", edgeIndex + i);
				ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
			}

			sprintf (buffer, "\t!#%d%s%s", polygonIndex, GS::EOL, GS::EOL);
			ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

			edgeIndex += pointsCount;
			polygonIndex++;
		}

		sprintf (buffer, "BODY 4%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);

		ACAPI_LibPart_EndSection ();

		// 2D script section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_Sect2DScript;
		ACAPI_LibPart_NewSection (&section);
		sprintf (buffer, "!%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "! 2D Script (Generated by Speckle Connector)%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "!%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "PEN gs_cont_pen%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "SET FILL gs_fill_type%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		sprintf (buffer, "PROJECT2{2} 3, 270.0, 3+32, gs_back_pen, 0, 0, 0%s", GS::EOL);
		ACAPI_LibPart_WriteSection (Strlen32 (buffer), buffer);
		ACAPI_LibPart_EndSection ();

		// Parameter script section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_SectVLScript;
		ACAPI_LibPart_NewSection (&section);
		ACAPI_LibPart_EndSection ();

		// Parameters section
		BNZeroMemory (&section, sizeof (API_LibPartSection));
		section.sectType = API_SectParamDef;

		short nPars = 2;
		API_AddParType** addPars = reinterpret_cast<API_AddParType**>(BMAllocateHandle (nPars * sizeof (API_AddParType), ALLOCATE_CLEAR, 0));
		if (addPars != nullptr) {
			API_AddParType* pAddPar = &(*addPars)[0];
			pAddPar->typeID = APIParT_Boolean;
			pAddPar->typeMod = 0;
			CHTruncate ("showOnlyContourEdgesIn3D", pAddPar->name, sizeof (pAddPar->name));
			GS::ucscpy (pAddPar->uDescname, L ("Show Only Contour Edges In 3D"));
			pAddPar->value.real = 1;

			pAddPar = &(*addPars)[1];
			pAddPar->typeID = APIParT_RealNum;
			pAddPar->typeMod = API_ParArray;
			pAddPar->dim1 = 4;
			pAddPar->dim2 = 3;
			CHTruncate ("map_xform", pAddPar->name, sizeof (pAddPar->name));
			GS::ucscpy (pAddPar->uDescname, L ("General Transformation"));
			pAddPar->value.array = BMAllocateHandle (pAddPar->dim1 * pAddPar->dim2 * sizeof (double), ALLOCATE_CLEAR, 0);
			double** arrHdl = reinterpret_cast<double**>(pAddPar->value.array);
			for (Int32 k = 0; k < pAddPar->dim1; k++)
				for (Int32 j = 0; j < pAddPar->dim2; j++)
					(*arrHdl)[k * pAddPar->dim2 + j] = (k == j ? 1.0 : 0.0);

			double aa = 1.0;
			double bb = 1.0;
			GSHandle sectionHdl = nullptr;
			ACAPI_LibPart_GetSect_ParamDef (&libPart, addPars, &aa, &bb, nullptr, &sectionHdl);

			API_LibPartDetails details;
			BNZeroMemory (&details, sizeof (API_LibPartDetails));
			details.object.autoHotspot = false;
			details.object.fixSize = true;
			ACAPI_LibPart_SetDetails_ParamDef (&libPart, sectionHdl, &details);

			ACAPI_LibPart_AddSection (&section, sectionHdl, nullptr);

			BMKillHandle (reinterpret_cast<GSHandle*>(&arrHdl));
			BMKillHandle (reinterpret_cast<GSHandle*>(&addPars));
			BMKillHandle (&sectionHdl);
		} else {
			err = APIERR_MEMFULL;
		}

		if (libPart.location != nullptr) {
			delete libPart.location;
			libPart.location = nullptr;
		}

		// Save the constructed library part
		if (err == NoError)
			err = ACAPI_LibPart_Save (&libPart);

		if (libPart.location != nullptr) {
			delete libPart.location;
			libPart.location = nullptr;
		}
	}

	return err;
}


GSErrCode LibpartImportManager::GetLocation (IO::Location*& loc, bool useEmbeddedLibrary) const
{
	GS::Array<API_LibraryInfo> libInfo;
	loc = nullptr;

	GSErrCode err = NoError;

	if (useEmbeddedLibrary) {
		Int32 embeddedLibraryIndex = -1;
		// get embedded library location
		if (ACAPI_Environment (APIEnv_GetLibrariesID, &libInfo, &embeddedLibraryIndex) == NoError && embeddedLibraryIndex >= 0) {
			try {
				loc = new IO::Location (libInfo[embeddedLibraryIndex].location);
			} catch (std::bad_alloc&) {
				return APIERR_MEMFULL;
			}

			if (loc != nullptr) {
				IO::Location ownFolderLoc (*loc);
				ownFolderLoc.AppendToLocal (IO::Name ("Speckle Library"));
				err = IO::fileSystem.CreateFolder (ownFolderLoc);
				if (err == NoError || err == IO::FileSystem::TargetExists)
					loc->AppendToLocal (IO::Name ("Speckle Library"));
			}
		}
	} else {
		// register our own folder and create the library part in it
		if (ACAPI_Environment (APIEnv_GetLibrariesID, &libInfo) == NoError) {
			IO::Location folderLoc;
			API_SpecFolderID specID = API_UserDocumentsFolderID;
			ACAPI_Environment (APIEnv_GetSpecFolderID, &specID, &folderLoc);
			folderLoc.AppendToLocal (IO::Name ("Speckle Library"));
			IO::Folder destFolder (folderLoc, IO::Folder::Create);
			if (destFolder.GetStatus () != NoError || !destFolder.IsWriteable ())
				return APIERR_GENERAL;

			loc = new IO::Location (folderLoc);

			for (UInt32 ii = 0; ii < libInfo.GetSize (); ii++) {
				if (folderLoc == libInfo[ii].location)
					return NoError;
			}

			try {
				API_LibraryInfo li;
				li.location = folderLoc;

				libInfo.Push (li);
			} catch (const GS::OutOfMemoryException&) {
				DBBREAK_STR ("Not enough memory");
				return APIERR_MEMFULL;
			}

			ACAPI_Environment (APIEnv_SetLibrariesID, &libInfo);
		}
	}

	return NoError;
}


GS::UInt64 LibpartImportManager::GenerateFingerPrint (const GS::Array<GS::UniString>& hashIds) const
{
	IO::MD5Channel md5Channel;
	MD5::FingerPrint checkSum;

	for (const GS::UniString& id : hashIds)
		md5Channel.Write (id);

	md5Channel.Finish (&checkSum);
	return checkSum.GetUInt64Value ();
}
